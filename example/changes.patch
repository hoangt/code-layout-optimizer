Index: include/llvm/CodeGen/Passes.h
===================================================================
--- include/llvm/CodeGen/Passes.h	(revision 200949)
+++ include/llvm/CodeGen/Passes.h	(working copy)
@@ -310,6 +310,10 @@
   /// Add standard basic block placement passes.
   virtual void addBlockPlacement();
 
+
+  /// rlavaee
+  virtual void addMBBTracing();
+
   /// addPreEmitPass - This pass may be implemented by targets that want to run
   /// passes immediately before machine code is emitted.  This should return
   /// true if -print-machineinstrs should print out the code after the passes.
@@ -568,6 +572,11 @@
   /// bundles (created earlier, e.g. during pre-RA scheduling).
   extern char &FinalizeMachineBundlesID;
 
+
+  /// rlavaee: MBBTracing - This pass inserts profiling instructions for
+  /// each machine basic block.
+  extern char &MBBTracingID;
+
 } // End llvm namespace
 
 #endif
Index: include/llvm/InitializePasses.h
===================================================================
--- include/llvm/InitializePasses.h	(revision 200949)
+++ include/llvm/InitializePasses.h	(working copy)
@@ -265,6 +265,9 @@
 void initializeSLPVectorizerPass(PassRegistry&);
 void initializeBBVectorizePass(PassRegistry&);
 void initializeMachineFunctionPrinterPassPass(PassRegistry&);
+
+///rlavaee
+void initializeMBBTracingPass(PassRegistry&);
 }
 
 #endif
Index: lib/CodeGen/LLVMTargetMachine.cpp
===================================================================
--- lib/CodeGen/LLVMTargetMachine.cpp	(revision 200949)
+++ lib/CodeGen/LLVMTargetMachine.cpp	(working copy)
@@ -216,7 +216,9 @@
   }
 
   // Create the AsmPrinter, which takes ownership of AsmStreamer if successful.
+  errs() << "Creating the printer\n";
   FunctionPass *Printer = getTarget().createAsmPrinter(*this, *AsmStreamer);
+  //errs() << "Before adding the streamer:\t" << PM.getAsPMDataManager->getNumContainedPasses()<<"\n-----\n";
   if (Printer == 0)
     return true;
 
@@ -224,6 +226,7 @@
   AsmStreamer.take();
 
   PM.add(Printer);
+  //errs() << "After adding the streamer:\t" << PM.getAsPMDataManager->getNumContainedPasses()<<"\n-----\n";
 
   return false;
 }
Index: lib/CodeGen/MBBTracing.cpp
===================================================================
--- lib/CodeGen/MBBTracing.cpp	(revision 0)
+++ lib/CodeGen/MBBTracing.cpp	(working copy)
@@ -0,0 +1,46 @@
+#include "llvm/CodeGen/MachineFunctionPass.h"
+#include "llvm/CodeGen/MachineFunction.h"
+#include "llvm/CodeGen/Passes.h"
+#include "llvm/Support/Debug.h"
+#include "llvm/Support/raw_ostream.h"
+using namespace llvm;
+
+namespace {
+  class MBBTracing : public MachineFunctionPass {
+    public:
+      static char ID;
+      MBBTracing(): MachineFunctionPass(ID){
+        initializeMBBTracingPass(*PassRegistry::getPassRegistry());
+      }
+
+      bool runOnMachineFunction(MachineFunction &MF);
+      
+  };
+}
+
+char MBBTracing::ID = 0;
+char &llvm::MBBTracingID = MBBTracing::ID;
+
+INITIALIZE_PASS(MBBTracing, "machine-block-trace",
+                "Inserts profiling information in every machine basic block", 
+                false, false)
+
+bool MBBTracing::runOnMachineFunction(MachineFunction &MF){
+  for (MachineFunction::iterator I = MF.begin(), E = MF.end(); I != E; 
+      I++){
+     MachineBasicBlock *MBB = I;
+    
+    for (MachineBasicBlock::iterator II = MBB->begin(), IE = MBB->end(); II != IE;
+        II++){
+      MachineInstr *MI = II;
+      if(MI->isCall()){
+        errs () << *MI << "\n---------\n";
+      }
+      
+    }
+
+  }
+
+  return false;
+}
+
Index: lib/CodeGen/Passes.cpp
===================================================================
--- lib/CodeGen/Passes.cpp	(revision 200949)
+++ lib/CodeGen/Passes.cpp	(working copy)
@@ -87,6 +87,10 @@
 static cl::opt<bool> EarlyLiveIntervals("early-live-intervals", cl::Hidden,
     cl::desc("Run live interval analysis earlier in the pipeline"));
 
+// rlavaee: enable machine block profiling
+static cl::opt<bool> EnableMBBTracing("enable-machine-block-tracing",cl::Hidden,
+    cl::desc("Enable Machine Block Tracing Instrumentation"));
+
 /// Allow standard passes to be disabled by command line options. This supports
 /// simple binary flags that either suppress the pass or do nothing.
 /// i.e. -disable-mypass=false has no effect.
@@ -536,6 +540,10 @@
 
   if (addPreEmitPass())
     printAndVerify("After PreEmit passes");
+
+  // rlavaee: add after all the other passes
+  if (EnableMBBTracing)
+    addMBBTracing();
 }
 
 /// Add passes that optimize machine instructions in SSA form.
@@ -749,3 +757,10 @@
     printAndVerify("After machine block placement.");
   }
 }
+
+/// rlavaee: Add machine block tracing instrumentation pass.
+void TargetPassConfig::addMBBTracing() {
+  if(addPass(&MBBTracingID)) {
+    printAndVerify("After machine block tracing instrumentation.");
+  }
+}
Index: lib/IR/LegacyPassManager.cpp
===================================================================
--- lib/IR/LegacyPassManager.cpp	(revision 200949)
+++ lib/IR/LegacyPassManager.cpp	(working copy)
@@ -981,6 +981,9 @@
 void PMDataManager::add(Pass *P, bool ProcessAnalysis) {
   // This manager is going to manage pass P. Set up analysis resolver
   // to connect them.
+  errs() << "Before adding the pass:\t" << getNumContainedPasses()<<"\n-----\n";
+  dumpPassArguments();
+  
   AnalysisResolver *AR = new AnalysisResolver(*this);
   P->setResolver(AR);
 
@@ -1052,6 +1055,7 @@
 
   // Add pass
   PassVector.push_back(P);
+  errs() << "After adding the pass:\t" << getNumContainedPasses()<<"\n-----\n";
 }
 
 
Index: lib/LTO/LTOCodeGenerator.cpp
===================================================================
--- lib/LTO/LTOCodeGenerator.cpp	(revision 200949)
+++ lib/LTO/LTOCodeGenerator.cpp	(working copy)
@@ -476,26 +476,33 @@
 
   PassManager codeGenPasses;
 
+  PassManager codeEmitterPass;
+
   codeGenPasses.add(new DataLayout(*TargetMach->getDataLayout()));
   TargetMach->addAnalysisPasses(codeGenPasses);
 
   formatted_raw_ostream Out(out);
 
+  codeEmitterPass.add(new DataLayout(*TargetMach->getDataLayout()));
+
   // If the bitcode files contain ARC code and were compiled with optimization,
   // the ObjCARCContractPass must be run, so do it unconditionally here.
   codeGenPasses.add(createObjCARCContractPass());
 
-  if (TargetMach->addPassesToEmitFile(codeGenPasses, Out,
+  if (TargetMach->addPassesToEmitFile(codeEmitterPass, Out,
                                       TargetMachine::CGFT_ObjectFile)) {
     errMsg = "target file type not supported";
     return false;
   }
 
+  //TargetMach->addAnalysisPasses(codeGenPasses);
+
   // Run our queue of passes all at once now, efficiently.
   passes.run(*mergedModule);
 
   // Run the code generator, and write assembly file
   codeGenPasses.run(*mergedModule);
+  codeEmitterPass.run(*mergedModule);
 
   return true;
 }
