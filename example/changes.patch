Index: lib/CodeGen/LLVMTargetMachine.cpp
===================================================================
--- lib/CodeGen/LLVMTargetMachine.cpp	(revision 200949)
+++ lib/CodeGen/LLVMTargetMachine.cpp	(working copy)
@@ -216,7 +216,9 @@
   }
 
   // Create the AsmPrinter, which takes ownership of AsmStreamer if successful.
+  errs() << "Creating the printer\n";
   FunctionPass *Printer = getTarget().createAsmPrinter(*this, *AsmStreamer);
+  //errs() << "Before adding the streamer:\t" << PM.getAsPMDataManager->getNumContainedPasses()<<"\n-----\n";
   if (Printer == 0)
     return true;
 
@@ -224,6 +226,7 @@
   AsmStreamer.take();
 
   PM.add(Printer);
+  //errs() << "After adding the streamer:\t" << PM.getAsPMDataManager->getNumContainedPasses()<<"\n-----\n";
 
   return false;
 }
Index: lib/IR/LegacyPassManager.cpp
===================================================================
--- lib/IR/LegacyPassManager.cpp	(revision 200949)
+++ lib/IR/LegacyPassManager.cpp	(working copy)
@@ -981,6 +981,9 @@
 void PMDataManager::add(Pass *P, bool ProcessAnalysis) {
   // This manager is going to manage pass P. Set up analysis resolver
   // to connect them.
+  errs() << "Before adding the pass:\t" << getNumContainedPasses()<<"\n-----\n";
+  dumpPassArguments();
+  
   AnalysisResolver *AR = new AnalysisResolver(*this);
   P->setResolver(AR);
 
@@ -1052,6 +1055,7 @@
 
   // Add pass
   PassVector.push_back(P);
+  errs() << "After adding the pass:\t" << getNumContainedPasses()<<"\n-----\n";
 }
 
 
Index: lib/LTO/LTOCodeGenerator.cpp
===================================================================
--- lib/LTO/LTOCodeGenerator.cpp	(revision 200949)
+++ lib/LTO/LTOCodeGenerator.cpp	(working copy)
@@ -476,26 +476,33 @@
 
   PassManager codeGenPasses;
 
+  PassManager codeEmitterPass;
+
   codeGenPasses.add(new DataLayout(*TargetMach->getDataLayout()));
   TargetMach->addAnalysisPasses(codeGenPasses);
 
   formatted_raw_ostream Out(out);
 
+  codeEmitterPass.add(new DataLayout(*TargetMach->getDataLayout()));
+
   // If the bitcode files contain ARC code and were compiled with optimization,
   // the ObjCARCContractPass must be run, so do it unconditionally here.
   codeGenPasses.add(createObjCARCContractPass());
 
-  if (TargetMach->addPassesToEmitFile(codeGenPasses, Out,
+  if (TargetMach->addPassesToEmitFile(codeEmitterPass, Out,
                                       TargetMachine::CGFT_ObjectFile)) {
     errMsg = "target file type not supported";
     return false;
   }
 
+  //TargetMach->addAnalysisPasses(codeGenPasses);
+
   // Run our queue of passes all at once now, efficiently.
   passes.run(*mergedModule);
 
   // Run the code generator, and write assembly file
   codeGenPasses.run(*mergedModule);
+  codeEmitterPass.run(*mergedModule);
 
   return true;
 }
